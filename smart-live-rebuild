#!/usr/bin/python
#	vim:fileencoding=utf-8
# Check all live ebuilds for updates and rebuild them if necessary.
# (C) 2010 Michał Górny <gentoo@mgorny.alt.pl>
# Released under the terms of the 3-clause BSD license or the GPL-2 license.

import os, sys
import portage

from optparse import OptionParser
try:
	from configparser import ConfigParser, NoOptionError
except ImportError: # py2
	from ConfigParser import ConfigParser, NoOptionError

from SmartLiveRebuild import PV
from SmartLiveRebuild.output import out

from SmartLiveRebuild.git import GitSupport
from SmartLiveRebuild.mercurial import HgSupport
from SmartLiveRebuild.subversion import SvnSupport
from SmartLiveRebuild.cvs import CVSSupport

from SmartLiveRebuild.core import SmartLiveRebuild

vcsl = [GitSupport, HgSupport, SvnSupport, CVSSupport]

def main(argv):
	opt = OptionParser(
			usage='%prog [options] -- [emerge options]',
			version='%%prog %s' % PV,
			description='Enumerate all live packages in system, check their repositories for updates and remerge the updated ones.'
	)
	opt.add_option('-c', '--config-file', action='store', dest='config_file',
		help='Configuration file (default: /etc/portage/smart-live-rebuild.conf)')
	opt.add_option('-C', '--no-color', action='store_false', dest='color',
		help='Disable colorful output.')
	opt.add_option('-E', '--no-erraneous-merge', action='store_false', dest='erraneous_merge',
		help='Disable emerging packages for which the update has failed.')
	opt.add_option('-j', '--jobs', action='store', type='int', dest='jobs',
		help='Spawn JOBS parallel processes to perform repository updates.')
	opt.add_option('-l', '--local-rev', action='store_true', dest='local_rev',
		help='Force determining the current package revision from the repository instead of using the one saved by portage.')
	opt.add_option('-N', '--no-network', action='store_false', dest='network',
		help='Disable network interaction and just aggregate already updated repositories (requires --local-rev not set).')
	opt.add_option('-O', '--no-offline', action='store_false', dest='offline',
		help='Disable setting ESCM_OFFLINE for emerge.')
	opt.add_option('-p', '--pretend', action='store_true', dest='pretend',
		help='Only print a list of the packages which were updated; do not call emerge to rebuild them.')
	opt.add_option('-P', '--profile', action='store', dest='profile',
		help='Configuration profile (config file section) to use (default: smart-live-rebuild)')
	opt.add_option('-Q', '--quickpkg', action='store_true', dest='quickpkg',
		help='Call quickpkg to create binary backups of packages which are going to be updated.')
	opt.add_option('-S', '--no-setuid', action='store_false', dest='setuid',
		help='Do not switch UID to portage when FEATURES=userpriv is set.')
	opt.add_option('-t', '--type', action='append', dest='type',
		help='Limit rebuild to packages using specific VCS (eclass name). If used multiple times, all specified VCS-es will be used.')
	opt.add_option('-U', '--unprivileged-user', action='store_true', dest='unprivileged_user',
		help='Allow running as an unprivileged user.')

	# Config&option parsing algo:
	# 1) set default configfile,
	# 2) parse opts to get configfile,
	# 3) set configfile defaults if applicable,
	# 4) reparse opts.
	defs = {
		'color': 'True',
		'erraneous_merge': 'True',
		'jobs': '1',
		'local_rev': 'False',
		'network': 'True',
		'offline': 'True',
		'pretend': 'False',
		'quickpkg': 'False',
		'setuid': str('userpriv' in portage.settings.features),
		'type': '',
		'unprivileged_user': 'False'
	}

	opt.set_defaults(
			config_file = '/etc/portage/smart-live-rebuild.conf',
			profile = 'smart-live-rebuild'
	)
	c = ConfigParser(defs)
	(opts, args) = opt.parse_args(argv[1:])

	# now look for the config file(s)
	cfl = [opts.config_file]
	sect = opts.profile
	try:
		while cfl[-1] != '' and c.read(os.path.expanduser(cfl[-1])):
			# config file chaining support
			try:
				cf = c.get(sect, 'config_file')
			except NoOptionError:
				break
			else:
				if cf not in cfl:
					cfl.append(cfl)
				else:
					break
	except Exception as e:
		out.err('Error while parsing configuration file:')
		out.err('%s: %s' % (e.__class__.__name__, e))

	# we need to have it to get the defaults
	if not c.has_section(sect):
		c.add_section(sect)

	# set defaults from the configfile and parse
	newdefs = {}
	deftypes = None
	for k, defv in defs.items():
		if defs[k] in ('True', 'False'): # bool
			try:
				newdefs[k] = c.getboolean(sect, k)
			except ValueError:
				out.err('Incorrect boolean value: %s=%s' % (k, c.get(sect, k)))
				newdefs[k] = (defv == 'True')
		elif k == 'jobs': # int
			try:
				newdefs[k] = c.getint(sect, k)
			except ValueError:
				out.err('Incorrect int value: %s=%s' % (k, c.get(sect, k)))
				newdefs[k] = int(defv)
		elif k == 'type':
			# this one needs special handling due to the append action
			t = c.get(sect, k)
			if t != '':
				deftypes = t.split(',')
		else:
			newdefs[k] = c.get(sect, k)
		
	opt.set_defaults(**newdefs)
	(opts, args) = opt.parse_args(argv[1:])
	if not opts.type:
		opts.type = deftypes

	return SmartLiveRebuild(opts, args, vcsl)

if __name__ == '__main__':
	sys.exit(main(sys.argv))
